# Programmer: Connor Fricke
# File: rk4.py
# Latest Revision: 9-APRIL-2024 --> Created
# Python script for validation of C++ segment of Visualizing Chaos project.
# This script performs the Runge-Kutta 4 Differential Equation solving algorithm,
# similarly to the C++ program in order to create another data file which can be
# compared to those generated by the C++ program to verify the correctness of the
# results.

# NOTE: THIS SCRIPT SOLVES THE DIFFEQ WITH A FIXED SET OF PARAMETERS FOR SIMPLICITY
# These parameters correspond to the limit cycles example calculated from the C++ program.
# omega0 = 1
# alpha = 0.2
# f_ext = 0.52
# w_ext = 0.694
# phi_ext = 0
# theta0 = 0.8
# theta_dot0 = 0.8

from math import cos, sin, pi
from numpy import arange
import os

# PATH STUFF
PROJ_DIR = os.getcwd()
DATA_PATH = PROJ_DIR + "/datafiles/"
OUTPUT_FILE = DATA_PATH + "python_results.dat"

# CONSTANTS
NMAX = 5
TMIN = 0
TMAX = 200.0
PLOT_SKIP = 10

# PARAMETERS FOR RHS:
omega0 = 1.0            # natural frequency of pendulum
alpha = 0.2             # damping force, viscous
f_ext = 0.52            # sinusoidal driving force amplitude
w_ext = 0.694           # sinusoidal driving force frequency
phi_ext = 0             # sinusoidal driving force phase constant
# INITIAL CONDITIONS:
theta0 = 0.8            # initial angular position
theta_dot0 = 0.8        # initial angular velocity
# PARAMETER FOR RK4:
T_ext = 2 * pi / w_ext  # external force period
h = T_ext / 1000.0      # time step for RK4 algorithm


# Let's set up the right hand side of the differential equation.
#  * This is the function defining the i'th right hand side of
#     the diffential equations:
#            dy[i]/dt = rhs(t,y[],i)
#  * We take this from eqs. (14.5) through (14.7) in Landau/Paez

# rhs(t, y, i):
# parameters:
#   t: floating point value
#   y: list-like object
#   i: integer
def rhs (t, y, i):
    # external force (driving motor)
    F_ext = f_ext * cos(w_ext * t + phi_ext)

    if (i == 0):
        return (y[1])
    if (i == 1):
        return (-omega0 * omega0 * sin(y[0]) - alpha * y[1] + F_ext)
    
    # we shouldn't get here
    return (1)

# ************************************************************************ 
#  
#   4th Order Runge-Kutta Differential Equation Solver
#
# This routine takes all of the y's one step, from t to t+h.  
#  The original values of y[0], y[1], etc. are lost.
#
# inputs:
#   N --- number of y(t)'s
#   t --- independent variable
#   y[] --- vector of y(t)'s
#   h --- step size
#   f --- function for the right hand sides
#
# outputs:
#   y[] --- predictions for the values of y(t+h)  
#
# Notes:
#   * The algorithm is from Eq.(9.46) in Landau and Paez.
#
#***********************************************************************
def runge4(N, t, y, h):
    # intermediate y-values
    y1 = [0, 0, 0, 0, 0]
    y2 = [0, 0, 0, 0, 0]
    y3 = [0, 0, 0, 0, 0]
    # RK4 notation
    k1 = [0, 0, 0, 0, 0]
    k2 = [0, 0, 0, 0, 0]
    k3 = [0, 0, 0, 0, 0]
    k4 = [0, 0, 0, 0, 0]

    # Runge-Kutta 4th Order Algorithm as defined in Landau and Paez Eq. 9.46
    for i in range(N):
        k1[i] = h * rhs(t, y, i)
        y1[i] = y[i] + k1[i] / 2.0  # argument for k2

    for i in range(N):
        k2[i] = h * rhs(t + h / 2.0, y1, i)
        y2[i] = y[i] + k2[i] / 2.0  # argument for k3
    
    for i in range(N):
        k3[i] = h * rhs(t + h / 2.0, y2, i)
        y3[i] = y[i] + k3[i]        # argument for k4
    
    for i in range(N):
        k4[i] = h * rhs(t + h, y3, i)

    for i in range(N):
        y[i] += (k1[i] + 2. * k2[i] + 2. * k3[i] + k4[i]) / 6.0

# ********** MAIN PROGRAM **************
N = 2
y_rk4 = [theta0, theta_dot0]
t = 0.0
# open output file and write header
out = open(OUTPUT_FILE, "w")
out.write("# omega0=1, alpha=0.2\n")
out.write("# theta0=0.8, theta_dot0=0.8\n")
out.write("# t_start=0, t_end=200, h=0.00905358\n")
out.write("#   t          theta(t)                 thetadot(t)\n")

theta = y_rk4[0]
theta_dot = y_rk4[1]
out.write(str(t) + " " + str(theta) + " " + str(theta_dot) + "\n")

point_count = 0
for t in arange(TMIN, TMAX, h):
    # run algorithm to get value at next step
    runge4(N, t, y_rk4, h)

    # increment point count
    point_count += 1
    
    # get theta and theta_dot
    theta = y_rk4[0]
    theta_dot = y_rk4[1]
    # plot (save to file) every PLOT_SKIP'th point
    if (point_count % PLOT_SKIP == 0):
        out.write(str(t+h) + " " + str(theta) + " " + str(theta_dot) + "\n")
# ******* END *********